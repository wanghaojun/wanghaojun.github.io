---
title: 数据库索引-2021春招
date: 2021-04-06 09:41:41
tags: [面试,数据库]
---

索引是定义在table基础之上，有助于无需检查所有记录而快速定位所需记录的一种**辅助存储结构**，由一系列存储在磁盘上的索引项组成，每一种索引项由索引字段和行指针构成。

<!--more-->

索引的好处：

- 通过创建索引,可以在查询的过程中,提高系统的性能；
- 通过创建唯一性索引,可以保证数据库表中每一行数据的唯一性；
- 在使用分组和排序子句进行数据检索时,可以减少查询中分组和排序的时间；

索引的坏处：

- 创建索引和维护索引要耗费时间,而且时间随着数据量的增加而增大；
- 索引需要占用物理空间,如果要建立聚簇索引,所需要的空间会更大；
- 在对表中的数据进行增加删除和修改时需要耗费较多的时间,因为索引也要动态地维护；

索引在 MySQL 数据库中分三类：

- B+ 树索引
- Hash 索引
- 全文索引

**B+ Tree索引和Hash索引区别** 

- 哈希索引适合等值查询，但是无法进行范围查询 
- 哈希索引没办法利用索引完成排序 
- 哈希索引不支持多列联合索引的最左匹配规则 
- 如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题

#### B+树

工作开发中最常接触到的 InnoDB 存储引擎中的 B+ 树索引。要介绍 B+ 树索引，就不得不提二叉查找树，平衡二叉树和 B 树这三种数据结构。B+ 树就是从他们仨演化来的。

![](http://img.wanghaojun.cn//other/20210405150758.png)

b树和b+树的区别：

- B+ 树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。
  之所以这么做是因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16KB。

  如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快。

  另外，B+ 树的阶数是等于键值的数量的，如果我们的 B+ 树一个节点可以存储 1000 个键值，那么 3 层 B+ 树可以存储 1000×1000×1000=10 亿个数据。

  一般根节点是常驻内存的，所以一般我们查找 10 亿数据，只需要 2 次磁盘 IO。

- B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。

  上图 B+ 树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。

  也就是说上图中的 B+ 树索引就是 InnoDB 中 B+ 树索引真正的实现方式，准确的说应该是聚集索引（聚集索引和非聚集索引下面会讲到）。

  通过上图可以看到，在 InnoDB 中，我们通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。

  MyISAM 中的 B+ 树索引实现与 InnoDB 中的略有不同。在 MyISAM 中，B+ 树索引的叶子节点并不存储数据，而是存储数据的文件地址。

#### 聚集索引VS非聚集索引

那什么是聚集索引呢？在 MySQL 中，B+ 树索引按照存储方式的不同分为聚集索引和非聚集索引。

这里我们着重介绍 InnoDB 中的聚集索引和非聚集索引：

**①聚集索引（聚簇索引）：**以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。

这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，在 B+ 树的叶子节点中，存储了表中所有的数据。

这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，我们称之为聚集索引。

**②非聚集索引（非聚簇索引）：**以主键以外的列值作为键值构建的 B+ 树索引，我们称之为非聚集索引。

非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。

明白了聚集索引和非聚集索引的定义，我们应该明白这样一句话：数据即索引，索引即数据。

**覆盖索引** 

覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。 如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。当我们通过SQL语句：select key2 from covering_index_sample where key1 = ‘keytest’;的时候，就可以通过覆盖索引查询，无需回表。

#### 联合索引

好几个字段组成的索引，称为联合索引。

联合索引遵循最左匹配原则，检索数据时从联合索引的最左边开始匹配。所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则。

范围字段会结束索引对范围后面索引字段的使用。

Like这种就是%在前面的不走索引，在后面的走索引

对索引列用函数了，不走索引

在WHERE和JOIN中出现的列需要建立索引，但也不完全如此，因为MySQL只对<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE才会使用索引（以通配符%和_开头作查询时，MySQL不会使用索引）。

#### 查询优化器

一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。 在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。这个成本最低的方案就是所谓的执行计划。 优化过程大致如下： 1、根据搜索条件，找出所有可能使用的索引 2、计算全表扫描的代价 3、计算使用不同索引执行查询的代价 4、对比各种执行方案的代价，找出成本最低的那一个

#### 稠密索引 稀疏索引

- 稠密索引：对于主文件中每一个记录都对应一个索引项；
  - 候选键属性的稠密索引：先查索引，然后再依据索引读主文件；
  - 非候选键属性的稠密索引：
    - 主文件按索引字段排序，索引文件中的索引字段值无重复；
    - 主文件索引字段未排序，但索引文件中的索引字段值是有重复的；
    - 主文件索引字段未排序且索引文件中的索引字段值无重复，这时可以引入指针桶来处理；
- 稀疏索引：对于主文件中部分记录有索引项和它对应（要求主文件必须是按对应索引字段属性排序存储）；

#### 主索引 辅助索引

- 主索引：对每个存储块有一个索引项，每个存储块的第一个记录叫锚，通常建立在有序文件的基于**主码**的排序字段上，属于稀疏索引。
- 辅助索引：是定义在主文件的任一或多个非排序字段上的辅助存储结构，属于稠密索引。

#### Myisam  Innodb

MyISAM

使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。

 Innodb

MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点data 域保存了完整的数据记录（第一个重大区别）。 这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。

第二个与 MyISAM 索引的不同是 InnoDB 的辅助索引 data 域存储相应记录主键的值而不是地址。换句话说，InnoDB 的所有辅助索引都引用主键作为 data 域。