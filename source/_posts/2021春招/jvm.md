---
title: jvm-2021春招
date: 2021-04-05 14:44:32
tags: [面试,java]
---

jvm基础知识：JVM垃圾回收算法、类加载过程、JVM分区、JVM内存模型

<!--more-->

#### JVM垃圾回收算法

垃圾回收算法 

标记清除 

标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段首先通过根节点，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶 段，清除所有未被标记的对象。标记清除算法带来的一个问题是会存在大量的空间碎片，因为回 收后的空间是不连续的，这样给大对象分配内存的时候可能会提前触发 full gc。

复制算法

将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存 活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存 的角色，完成垃圾回收。

 现在的商业虚拟机都采用这种收集算法来回收新生代，IBM 研究表明新生代中的对象 98%是 朝夕生死的，所以并不需要按照 1:1 的比例划分内存空间，而是将内存分为一块较大的 Eden 空 间和两块较小的 Survivor 空间，每次使用 Eden 和其中的一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地拷贝到另外一个 Survivor 空间上，最后清理掉 Eden 和刚 才用过的 Survivor 的空间。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1(可以通过 -SurvivorRattio 来配置)，也就是每次新生代中可用内存空间为整个新生代容量的 90%，只有 10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证回 收都只有不多于 10%的对象存活，当 Survivor 空间不够用时，需要依赖其他内存（这里指老年 代）进行分配担保。

标记整理 

复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发 生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活 的对象较多，复制的成本也将很高。 标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。首先 也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而 是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片 的产生，又不需要两块相同的内存空间，因此，其性价比比较高。

增量算法

增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿， 那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的 内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。使用这种方式，由于在垃 圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程 切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。

收集器

Serial 收集器 Serial 收集器是最古老的收集器，它的缺点是当 Serial 收集器想进行垃圾回收的时候，必 须暂停用户的所有进程，即 stop the world。

Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用”标记－整 理“算法。

ParNew 收集器是 Serial 收集器新生代的多线程实现，注意在进行垃圾回收的时候依然会 stop the world，只是相比较 Serial 收集器而言它会运行多条进程进行垃圾回收。

Parallel 是采用复制算法的多线程新生代垃圾回收器，似乎和 ParNew 收集器有很多的相似 的地方。

CMS 收集器 CMS(Concurrent Mark Swep)收集器是一个比较重要的回收器，现在应用非常广泛，我们重点来看一下，CMS一种获取最短回收停顿时间为目标的收集器，这使得它很适合用于和用户交互的业务。从名字(Mark Swep)就可以看出，CMS 收集器是基于标记清除算法实现的。它的收集过 程分为四个步骤：

- 初始标记(initial mark) 
- 并发标记(concurrent mark) 
- 重新标记(remark)
- 并发清除(concurrent sweep) 

注意初始标记和重新标记还是会 stop the world，但是在耗费时间更长的并发标记和并发 清除两个阶段都可以和用户进程同时工作。

#### 类加载过程

JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化，

加载 加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行 时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。 

验证 这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的 要求，并且不会危害虚拟机自身的安全。 

准备 准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量 所使用的内存空间。

初始化 初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类 加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代 码。

#### JVM分区

java 内存通常被划分为 5 个区域：程序计数器（Program Count Register）、本地方法栈 （Native Stack）、方法区（Methon Area）、栈（Stack）、堆（Heap）

#### JVM内存模型

Java 内存模型(简称 JMM)，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从 抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存 （main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该 线程以读/写共享变量的副本。