---
title: 网络原理-2021春招
date: 2021-04-07 13:20:44
tags: [面试,网络原理]
---

OSI七层与TCP/IP五层网络架构、IPv4 & IPv6、TCP协议 三次握手四次挥手、HTTP、常见端口

<!--more-->

#### OSI七层与TCP/IP五层网络架构 

应用层: 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 

表示层:数据格式化，代码转换，数据加密 没有协议 

会话层: 解除或建立与别的接点的联系 没有协议 

传输层: 提供端对端的接口 TCP，UDP 

网络层: 传输数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP，ARP(IP->MAC)，RAPR ICMP协议主要用来检测网络通信故障和实现链路追踪，最典型的应用就是PING和tracerooute 

数据链路层: 传输数据帧 SLIP，CSLIP，PPP，ARP，RARP，MTU 

物理层: 二进制比特位的传输 ISO2110，IEEE802，IEEE802.2

#### 网络层

##### IPv4 & IPv6

IPv4协议具有32位（4字节）地址长度；

点分十进制 内网地址分为A，B和C类

- A类地址范围：10.0.0.0 - 10.255.255.255 
- B类地址范围：172.16.0.0 - 172.31.255.255 
- C类地址范围：192.168.0.0 - 192.168.255.255 

IPv6协议具有128位（16字节）地址长度；冒分十六进制

##### IP字段

![](http://img.wanghaojun.cn//other/20210417164019.png)

版本：L3协议版本号，IPv4或IPv6 

首部长度：单位为4字节 

标识：每一个IP封包都有一个16位的唯一识别码｡当程序产生的数据要通过网络传送时都会被拆散成封包形式发送,当封包要进行重组的时候这个ID就是依据了，占16位｡

 协议：L4协议类型 

TTL生存时间字段设置了数据报可以经过的最多路由器数。一旦经过一个处理它的路由器，它的值就减1。当该字段值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。 

首部校验和(Header checksum): 这个数值用来检错用的,用以确保封包被正确无误的接收到｡当封包开始进行传送后,接收端主机会利用这个检验值会来检验余下的封包,如果一切无误就会发出确认信息表示接收正常｡与UDP和TCP协议包头中的校验和作用是一样的｡占16位｡ 首部检验和字段是根据IP首部计算的检验和码,不对首部后面的数据进行计算



#### 传输层

##### TCP字段 

数据格式：

![](http://img.wanghaojun.cn//other/20210329085717.png)

- seq：序列号，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号 
- ack：确认号，待收到对方下一个报文段的第一个数据字节的序号 
- 确认ACK标志位：ACK=1时，确认号字段才有效
- 同步SYN标志位：连接建立时用于同步序号。当SYN=1，ACK=0时表示连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。 
- 终止FIN标志位：用来释放一个连接。FIN=1表示此报文段的发送方的数据已经发送完毕，并释放连接。
- URG：紧急指针有效 
- ACK：确认号有效 
- PSH：接收方应该尽快将这个报文段交给应用层 
- RST：重建连接 
- SYN：同步序号用来发起一个连接

##### TCP建立连接

三次握手：

![](http://img.wanghaojun.cn//other/20210329090114.png)

- 发送方: 打开SYN=1，自带序列号seq-x希望建立链接 
- 接收方：打开SYN=1，自带序列号seq-y。并且确认接收到了seq-x，并希望收到ack=seq-(x+1)，ACK=1时，ack才有效 
- 发送方：自带序列号seq-(x+1)。确认接收到了seq-y，并希望收到ack=seq-(y+1)，ACK=1时，ack才有效

四次挥手：

![](http://img.wanghaojun.cn//other/20210329090732.png)

- 发送方：FIN=1，自带序列号seq-u。进入FIN-WAIT-1（终止等待1）状态。FIN报文段即使不携带数据，也要消耗一个序号。 
- 接收方：自带序列号seq-v，确认接收到了seq-u, 并希望收到ack=seq-(u+1)，ACK=1时，ack才有效。服务端就入了CLOSE-WAIT（关闭等待）状态。发送方收到变为FIN-WAIT-2
- 接收方将数据发送完成 
- 接收方：FIN=1，自带序列号seq-w，确认接收到了seq-u, 并希望收到ack=seq-(u+1)，ACK=1时，ack才有效。变为LAST-ACK（最后确认）状态 
- 发送方：自带序列号seq-(u+1)，确认接收到了seq-w, 并希望收到ack=seq-(w+1)，ACK=1时，ack才有效。发送方变为TIME_WAIT状态

##### 滑动窗口协议

滑动窗口协议（Sliding Window Protocol） 

属于TCP协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输，提高网络吞吐量。 

滑动窗口，可以理解成接收端所能提供的缓冲区大小。TCP利用一个滑动的窗口来告诉发送端对它所发送的数据能提供多大的缓冲区。由于窗口由16位bit所定义，所以接收端TCP 能最大提供65535个字节的缓冲。由此，可以利用窗口大小和第一个数据的序列号计算出最大可接收的数据序列号。 

滑动窗口本质上是描述接受方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据。如果发送方收到接受方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接受方发送窗口大小不为0的数据报的到来。

##### TCP拥塞控制

![](http://img.wanghaojun.cn//other/20210417164729.png)

cwnd: 拥塞窗口 

ssthresh: 门限 

过程: 

- 慢开始: 初始化拥塞窗口为1，发送 1 2 4 8个报文段 
- 拥塞控制：当拥塞窗口增长到慢开始的门限制时改为拥塞避免，加法增大 
- 超时重传：ssthresh减半，cwnd设为1
- 快重传: 
  - 使发送方尽快进行重传，而不是等待重传计时器超时再重传 
  - 发送方一段收到三个重复确认就立刻重传 
- 快恢复：门限制为当前窗口的一半，cwnd为奇数一般向下取整

##### **Nagle算法**

Nagle算法要求，一个TCP连接在任意时刻，最多只能有一个没有被确认的小段。所谓“小段”指的是小于MSS的数据块，“没有被确认”指的是一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。

Nagle算法的实现规则：

1. 如果包长度达到MSS，则允许发送；
2. 如果该包含有FIN，则允许发送；
3. 设置了TCP_NODELAY选项，则允许发送；
4. 未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；
5. 上述条件都未满足，但发生了超时（一般为200ms），则立即发送。

##### **延迟确认**

接收方收到数据包以后如果暂时没有数据要发给对端，它可以等一段时再确认（Linux上默认是40ms）。如果这段时间刚好有数据要传给对端，Ack就随着数据传输，而不需要单独发送一次Ack。如果超过时间还没有数据要发送，也发送Ack，避免对端以为丢包。

##### UDP字段

![](http://img.wanghaojun.cn//other/20210417164324.png)

校验和字段 ：是指整个UDP报文头和UDP所带的数据的校验和（也包括伪报文头）。伪报文头不包括在真正的UDP报文头中，但是它可以保证UDP数据被正确的主机收到了。因在校验和中加入了伪头标，故ICMP除能防止单纯数据差错之外，对IP分组也具有保护作用。

#### 应用层

##### HTTP

> HTTP协议是超文本传输协议（默认端口80）

HTTP特点: 

- 无状态(无连接)：HTTP 是一个无状态协议，这意味着每个请求都是独立的。 
  - 请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端。但每次都要建立TCP请求，效率低 
  - Keep-Alive 被提出用来解决这效率低的问题。就是长连接。

http过程：

- 浏览器发送url-http请求，根据域名解析出IP（浏览器缓冲->本机->DNS服务器）
- 浏览器与WEB服务器建立TCP请求，发起http请求，解析那个路径下那个资源 
- WEB服务器响应HTTP请求，80端口，返回html代码 
- 浏览器解析html代码，关闭TCP连接

##### HTTPS

![](http://img.wanghaojun.cn//other/20210407192740.png)

1. client向server发送请求，然后连接到server的443端口，发送的信息主要是随机值1和客户端支持的加密算法。

2. server接收到信息之后给予client响应握手信息，包括随机值2和匹配好的协商加密算法，这个加密算法一定是client发送给server加密算法的子集。

3. 随即server给client发送第二个响应报文是数字证书。服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。传送证书，这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。

4. 客户端解析证书，这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值（预主秘钥）。

5. 客户端认证证书通过之后，接下来是通过随机值1、随机值2和预主秘钥组装会话秘钥。然后通过证书的公钥加密会话秘钥。

6. 传送加密信息，这部分传送的是用证书加密后的会话秘钥，目的就是让服务端使用秘钥解密得到随机值1、随机值2和预主秘钥。

7. 服务端解密得到随机值1、随机值2和预主秘钥，然后组装会话秘钥，跟客户端会话秘钥相同。

8. 客户端通过会话秘钥加密一条消息发送给服务端，主要验证服务端是否正常接受客户端加密的消息。

9. 同样服务端也会通过会话秘钥加密一条消息回传给客户端，如果客户端能够正常接受的话表明SSL层连接建立完成了。

##### http2

新特性：

**多路复用 (Multiplexing)**

多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。所有的请求都是通过一个 TCP 连接并发完成。 HTTP/2 做到了真正的并发请求。同时，流还支持优先级和流量控制。

**二进制分帧**

在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。

在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）, 并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。

**首部压缩（Header Compression）**

HTTP/2 则使用了专门为首部压缩而设计的 [HPACK](https://link.zhihu.com/?target=http%3A//http2.github.io/http2-spec/compression.html) 算法。

**服务端推送（Server Push）**

服务端能够更快的把资源推送给客户端。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求。当客户端需要的时候，它已经在客户端了。

#### 常见端口

- 21端口：FTP 文件传输服务 
- 22端口：SSH 端口 
- 23端口：TELNET 终端仿真服务 
- 25端口：SMTP 简单邮件传输服务 
- 53端口：DNS 域名解析服务 
- 80端口：HTTP 超文本传输服务 
- 110端口：POP3 “邮局协议版本3”使用的端口 
- 443端口：HTTPS 加密的超文本传输服务 
- 3306端口：MYSQL 默认端口号

#### 问题

问题1: 为什么连接的时候是三次握手，关闭的时候却是四次握手？

> 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。我收到了，你发数据吧
>
> 关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文+ACK。故需要四步握手。我收到了，等我发完数据，我关闭了

问题2: 为什么不能用两次握手进行连接？

> 3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。
>
> 两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

问题3: 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE？ 

> - 为了保证A发送的最后一个ACK报文段能够到达B 
> - 防止已经断开的连接1中在链路中残留的FIN包终止掉新的连接2 
> - 防止链路上已经关闭的连接的残余数据包干扰正常的数据包，造成数据流不正常
> - 可以看出：接收方结束TCP连接的时间比发送方早一点，因为接收方收到确认就断开连接了，而A还得等待2MSL。

问题4: TIME_WAIT会带来哪些问题？

>  (1) 作为服务器，短时间内关闭了大量的Client连接，就会造成服务器上出现大量的TIME_WAIT连接，占据大量的tuple，严重消耗着服务器的资源；
>
>  (2) 作为客户端，短时间内大量的短连接，会大量消耗Client机器的端口，毕竟端口只有65535个，端口被耗尽了，后续就无法再发起新的连接了

问题5: 服务端time_wait过多的处理办法

>  net.ipv4.tcp_tw_reuse=1 （/etc/sysctl.conf） 
>
>  表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；该文件表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接(这个对快速重启动某些服务,而启动后提示端口已经被使用的情形非常有帮助) 
>
>  net.ipv4.tcp_tw_recycle=1 
>
>  表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭 
>
>  net.ipv4.tcp_timestamps=1 
>
>  表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭

问题6: ACK攻击 

> ACK Flooding攻击是在TCP连接建立之后，所有的数据传输TCP报文都是带有ACK标志位的，主机在接收到一个带有ACK标志位的数据包的时候，需要检查该数据包所表示的连接四元组是否存在，如果存在则检查该数据包所表示的状态是否合法，然后再向应用层传递该数据包。
>
> 如果在检查中发现该数据包不合法，例如该数据包所指向的目的端口在本机并未开放，则主机操作系统协议栈会回应RST包告诉对方此端口不存在。 
>
> 当发包速率很大的时候，主机操作系统将耗费大量的精力接收报文、判断状态，同时要主动回应RST报文，正常的数据包就可能无法得到及时的处理.